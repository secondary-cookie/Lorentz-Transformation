<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lorentz Transformation</title>
    <style>
        /* --- Styles --- */
        :root {
            --bg: #050505;
            --panel: #111;
            --blue: #4facfe;
            --gold: #FFD700;
            --red: #ff4444;
            --text: #eee;
            --border: #333;
        }

        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; }

        /* Sidebar */
        #sidebar {
            width: 380px; min-width: 380px; background: var(--panel); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; height: 100vh;
        }
        
        .header { padding: 20px; background: #181818; border-bottom: 1px solid var(--border); }
        h1 { margin: 0; font-size: 1.4rem; font-weight: 600; letter-spacing: 1px; }
        h1 span { color: var(--blue); font-weight: 300; }

        .content { padding: 20px; overflow-y: auto; flex: 1; }
        
        /* Controls */
        .control-box { background: #1a1a1a; padding: 15px; border-radius: 8px; border: 1px solid #333; margin-bottom: 20px; }
        .row { display: flex; gap: 10px; margin-top: 10px; }
        input { background: #000; border: 1px solid #555; color: #fff; padding: 10px; width: 60px; text-align: center; border-radius: 4px; font-size: 1rem; }
        button { padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; flex: 1; color: #000; transition: 0.2s; }
        .btn-go { background: var(--blue); }
        .btn-go:hover { filter: brightness(1.1); }
        .btn-back { background: #444; color: #fff; }
        .btn-back:hover { background: #555; }

        /* Algebra Box */
        .math-display {
            background: rgba(255,255,255,0.05); padding: 15px; border-radius: 6px; 
            border: 1px solid #444; font-family: 'Times New Roman', serif; 
            font-size: 1.1rem; line-height: 1.6; margin-bottom: 20px;
        }
        .hl { color: var(--blue); font-weight: bold; }
        .var { opacity: 0.7; }

        /* Legend */
        .legend-box { border-top: 1px solid #333; padding-top: 15px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 10px; font-size: 0.9rem; color: #ccc; }
        .icon { width: 12px; height: 12px; border-radius: 50%; margin-right: 10px; display: inline-block; }
        .line-icon { width: 20px; height: 3px; margin-right: 10px; display: inline-block; }

        /* Canvas */
        #canvas-area { flex: 1; position: relative; cursor: grab; background: #000; }
        #canvas-area:active { cursor: grabbing; }
        canvas { display: block; }

        .hud { position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 0.7rem; pointer-events: none;}
    </style>
</head>
<body>

<div id="sidebar">
    <div class="header">
        <h1>Lorentz <span>Transformation</span></h1>
    </div>
    <div class="content">
        <div class="control-box">
            <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#888;">
                <label>VELOCITY (v/c)</label>
                <span>Status: <span id="statusText" style="color:#aaa">Ready</span></span>
            </div>
            <div class="row">
                <input type="number" id="inpBeta" value="0.6" step="0.1" max="0.99" min="-0.99">
                <button class="btn-go" onclick="run()">TRANSFORM</button>
                <button class="btn-back" onclick="reset()">REWIND</button>
            </div>
        </div>

        <div style="font-size:0.8rem; color:#888; margin-bottom:5px;">CURRENT TRANSFORMATION</div>
        <div class="math-display">
            <div style="display:flex; justify-content:center; gap:10px; margin-bottom:15px;">
                <div style="border-left:2px solid #888; border-top:2px solid #888; border-bottom:2px solid #888; width:10px;"></div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px 15px; text-align:right;">
                    <span id="m00">1.00</span> <span id="m01">0.00</span>
                    <span id="m10">0.00</span> <span id="m11">1.00</span>
                </div>
                <div style="border-right:2px solid #888; border-top:2px solid #888; border-bottom:2px solid #888; width:10px;"></div>
            </div>
            <div id="eqText">
                t' = 1.00t - 0.00x<br>
                x' = -0.00t + 1.00x
            </div>
        </div>

        <div class="legend-box">
            <div style="font-size:0.8rem; color:#888; margin-bottom:10px;">LEGEND & MEANING</div>
            
            <div class="legend-item">
                <span class="icon" style="background:var(--red)"></span>
                <span>Event B (Particle)</span>
            </div>
            <div class="legend-item">
                <span class="line-icon" style="background:var(--red)"></span>
                <span>History Trace (Invariant Interval)</span>
            </div>
            <div class="legend-item">
                <span class="icon" style="background:var(--gold)"></span>
                <span>Photon</span>
            </div>
            <div class="legend-item">
                <span class="line-icon" style="background:var(--gold)"></span>
                <span>Light Path (Generated by Photon)</span>
            </div>
            
            <div style="margin-top:10px; font-size:0.8rem; color:#666; line-height:1.4;">
                Note how the yellow light path is generated at exactly 45Â°, regardless of the grid distortion.
            </div>
        </div>
    </div>
</div>

<div id="canvas-area">
    <canvas id="cvs"></canvas>
    <div class="hud">Pan: Drag | Zoom: Scroll</div>
</div>

<script>
    // --- Config ---
    const CFG = {
        scale: 100, // Pixels per unit
        colors: {
            grid: "rgba(0, 229, 255, 0.2)",
            axis: "#FFF",
            light: "#FFD700", // Yellow
            traceRed: "rgba(255, 68, 68, 0.9)",
            traceYellow: "rgba(255, 215, 0, 0.5)" 
        },
        speed: 0.03
    };

    // --- State ---
    const state = {
        beta: 0,
        target: 0,
        running: false,
        w: 0, h: 0
    };

    const cam = {
        x: 0, y: 0, z: 1.0,
        drag: false, lx: 0, ly: 0, cx: 0, cy: 0
    };

    // --- Events to Track ---
    // 1. Particle B (Timelike) at x=0, t=5
    // 2. Photon P (Lightlike) at x=5, t=5
    const events = [
        { id: 'B', x: 0, t: 5, color: CFG.colors.traceRed, type: 'dot' },
        { id: 'P', x: 5, t: 5, color: CFG.colors.light, type: 'photon' }
    ];
    
    // History Trails
    let trails = events.map(() => []);

    // --- Setup ---
    const canvas = document.getElementById('cvs');
    const ctx = canvas.getContext('2d');
    const box = document.getElementById('canvas-area');

    // --- Physics ---
    function lorentz(x, t, b) {
        const safeB = Math.max(-0.999, Math.min(0.999, b));
        const g = 1 / Math.sqrt(1 - safeB*safeB);
        return {
            x: g * (x - safeB * t),
            t: g * (t - safeB * x)
        };
    }

    function toScreen(x, t) {
        // Physics (Up=+t) to Canvas (Down=+y)
        const sx = (x * CFG.scale + cam.x) * cam.z + cam.cx;
        const sy = (-t * CFG.scale + cam.y) * cam.z + cam.cy;
        return { x: sx, y: sy };
    }

    // --- UI Updates ---
    function updateUI(b) {
        const safeB = Math.max(-0.999, Math.min(0.999, b));
        const g = 1 / Math.sqrt(1 - safeB*safeB);
        const bg = safeB * g;

        // Matrix
        document.getElementById('m00').innerText = g.toFixed(2);
        document.getElementById('m01').innerText = (-bg).toFixed(2);
        document.getElementById('m10').innerText = (-bg).toFixed(2);
        document.getElementById('m11').innerText = g.toFixed(2);

        // Equation
        document.getElementById('eqText').innerHTML = `
            ct' = <span class="hl">${g.toFixed(2)}</span><span class="var">ct</span> ${(-bg)>=0?'+':''} <span class="hl">${(-bg).toFixed(2)}</span><span class="var">x</span><br>
            x'  = <span class="hl">${(-bg).toFixed(2)}</span><span class="var">ct</span> + <span class="hl">${g.toFixed(2)}</span><span class="var">x</span>
        `;
    }

    // --- Rendering ---
    function draw() {
        // Clear
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, state.w, state.h);

        updateUI(state.beta);

        const z = cam.z;
        
        // 1. Draw Grid
        const range = 60;
        ctx.lineWidth = 1 * z;
        
        for(let i=-range; i<=range; i++) {
            const isAxis = (i===0);
            const col = isAxis ? CFG.colors.axis : CFG.colors.grid;
            const w = isAxis ? 2*z : 1*z;

            // Vertical lines (transformed x=i)
            let p1 = lorentz(i, -range, state.beta);
            let p2 = lorentz(i, range, state.beta);
            line(p1, p2, col, w);

            // Horizontal lines (transformed t=i)
            let p3 = lorentz(-range, i, state.beta);
            let p4 = lorentz(range, i, state.beta);
            line(p3, p4, col, w);
            
            // --- DRAW LABELS & TICKS ON AXES ---
            if (isAxis) {
                // Determine label position based on current transformation
                // Time Axis (ct') label: put it at t=6
                let tTip = lorentz(0, 8, state.beta);
                let xTip = lorentz(8, 0, state.beta);
                
                // Draw Axis Names
                drawText("ct'", tTip, "#FFF", 16*z, "center");
                drawText("x'", xTip, "#FFF", 16*z, "center");

                // Draw Ticks (every 5 units)
                for (let k = 5; k < range; k+=5) {
                    // Time Axis Ticks
                    let tTickPos = lorentz(0, k, state.beta);
                    drawText(k.toString(), tTickPos, "rgba(255,255,255,0.7)", 10*z, "right", 10);
                    
                    // Space Axis Ticks
                    let xTickPos = lorentz(k, 0, state.beta);
                    drawText(k.toString(), xTickPos, "rgba(255,255,255,0.7)", 10*z, "center", 15);
                }
            }
        }

        // 2. Draw Trails
        trails.forEach((path, idx) => {
            if(path.length < 2) return;
            const evt = events[idx];
            ctx.beginPath();
            ctx.strokeStyle = (evt.type === 'photon') ? CFG.colors.light : CFG.colors.traceRed;
            ctx.lineWidth = (evt.type === 'photon') ? 4*z : 3*z; 
            
            let start = toScreen(path[0].x, path[0].t);
            ctx.moveTo(start.x, start.y);
            
            for(let i=1; i<path.length; i++) {
                let p = toScreen(path[i].x, path[i].t);
                ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
        });

        // 3. Draw Points
        events.forEach((evt) => {
            let pos = lorentz(evt.x, evt.t, state.beta);
            let sc = toScreen(pos.x, pos.t);

            if(evt.type === 'photon') {
                ctx.beginPath();
                ctx.arc(sc.x, sc.y, 6*z, 0, Math.PI*2);
                ctx.fillStyle = "#FFF";
                ctx.fill();
                ctx.shadowBlur = 15;
                ctx.shadowColor = CFG.colors.light;
                ctx.stroke(); 
                ctx.shadowBlur = 0;
            } else {
                ctx.beginPath();
                ctx.arc(sc.x, sc.y, 5*z, 0, Math.PI*2);
                ctx.fillStyle = evt.color;
                ctx.fill();
            }
        });
    }

    function line(p1, p2, col, w) {
        let s1 = toScreen(p1.x, p1.t);
        let s2 = toScreen(p2.x, p2.t);
        if(Math.abs(s1.x) > 20000 || Math.abs(s1.y) > 20000) return;
        ctx.beginPath(); ctx.strokeStyle = col; ctx.lineWidth = w;
        ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    }
    
    function drawText(txt, pos, col, size, align="center", offset=0) {
        let sc = toScreen(pos.x, pos.t);
        if(Math.abs(sc.x) > 20000 || Math.abs(sc.y) > 20000) return;
        ctx.fillStyle = col;
        ctx.font = `bold ${size}px sans-serif`;
        ctx.textAlign = align;
        // Simple offset handling
        let dy = (align === "center") ? 20 : 5;
        if(offset) dy = offset;
        ctx.fillText(txt, sc.x - (align==="right"? 10 : 0), sc.y + dy);
    }

    // --- Loop ---
    function loop() {
        let diff = state.target - state.beta;
        if(Math.abs(diff) < 0.0005) {
            state.beta = state.target;
            if(Math.abs(state.target) < 0.001) trails = events.map(() => []); 
            state.running = false;
            document.getElementById('statusText').innerText = "Done";
            draw();
            return;
        }
        state.beta += diff * CFG.speed;
        events.forEach((evt, i) => trails[i].push(lorentz(evt.x, evt.t, state.beta)));
        draw();
        requestAnimationFrame(loop);
    }

    function run() {
        let v = parseFloat(document.getElementById('inpBeta').value);
        state.target = Math.max(-0.99, Math.min(0.99, v));
        if(!state.running) {
            state.running = true;
            document.getElementById('statusText').innerText = "Running...";
            loop();
        }
    }

    function reset() {
        state.target = 0;
        if(!state.running) {
            state.running = true;
            document.getElementById('statusText').innerText = "Rewinding...";
            loop();
        }
    }

    // --- Interactive ---
    function resize() {
        let r = box.getBoundingClientRect();
        if(r.width===0) return;
        let dpr = window.devicePixelRatio || 1;
        canvas.width = r.width * dpr; canvas.height = r.height * dpr;
        state.w = r.width; state.h = r.height;
        ctx.scale(dpr, dpr);
        cam.cx = state.w/2; cam.cy = state.h/2;
        draw();
    }
    window.addEventListener('resize', resize);

    box.addEventListener('mousedown', e => {
        cam.drag = true; cam.lx = e.clientX; cam.ly = e.clientY;
        box.style.cursor = 'grabbing';
    });
    window.addEventListener('mouseup', () => { cam.drag = false; box.style.cursor = 'grab'; });
    box.addEventListener('mousemove', e => {
        if(!cam.drag) return;
        let dx = e.clientX - cam.lx; let dy = e.clientY - cam.ly;
        cam.x += dx/cam.z; cam.y += dy/cam.z;
        cam.lx = e.clientX; cam.ly = e.clientY;
        draw();
    });
    box.addEventListener('wheel', e => {
        e.preventDefault();
        let f = e.deltaY < 0 ? 1.1 : 0.9;
        cam.z = Math.max(0.1, Math.min(10, cam.z * f));
        draw();
    });

    setTimeout(() => { resize(); draw(); }, 100);

</script>
</body>
</html>